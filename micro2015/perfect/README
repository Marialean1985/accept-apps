before running experiments, source cfg-perfect.sh by executing:
**this is also sourced by run-kernel.sh, and assumes cfg-perfect.sh in same directory

source cfg-perfect.sh



Notes of kernels:
2d_convolution: LARGE, long run time
dwt53: LARGE, bad annotations (seg faults on large fraction of runs)
histogram_equalization: LARGE
fft-1d: LARGE, annotations not representative of how we would approximate fft
fft-2d: SMALL
bp: SMALL, long run times
pfa-interp1: LARGE
pfa-interp2: LARGE
inner-product: LARGE
outer-product: LARGE
system-solve: LARGE
change-detection: LARGE
debayer: LARGE
lucas-kanade: LARGE


Steps for energy and error numbers:

1. on cluster, execute run.py to run error injection experiments
2. for each kernel, execute './run-profiling.sh app kernel' once to generate profile
3. execute ./run-build-usage.sh for each app/kernel './run-build-usage.sh app kernel'
4. execute ./run-compute.sh to compile profile file from raw data for all app/kernel pairs
5. go to approx-limit/models/simple and build REACT by executing 'make', then compile models using './run-build-models.sh'
6. execute ./run-react-detail.sh to generate energy numbers for all app/kernel pairs